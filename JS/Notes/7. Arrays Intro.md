# 📌 Arrays in JavaScript — Introduction & Creation

## 1. What is an Array?

* An **Array** is a special type of object in JavaScript that stores elements in an **ordered, indexed collection**.
* Indexes always start at **0**.
* Unlike some languages (like Java, C#), JS arrays are **dynamic**:

  * You don’t need to declare a fixed size.
  * You can store **mixed datatypes** in the same array.

```js
let arr = [1, "hello", true, { name: "JS" }, [2, 3]];
console.log(arr);
// [1, "hello", true, { name: "JS" }, [2, 3]]
```

---

## 2. Creating Arrays

### (a) Array Literal ✅ (most common)

```js
let fruits = ["apple", "banana", "cherry"];
```

### (b) Using `new Array()` ❌ (confusing sometimes)

```js
let numbers = new Array(3);  // creates empty array with length = 3
console.log(numbers);        // [ <3 empty items> ]
console.log(numbers.length); // 3
```

```js
let numbers2 = new Array(1, 2, 3); 
console.log(numbers2); // [1, 2, 3]
```

⚠️ Pitfall: `new Array(3)` doesn’t create `[3]`, it creates 3 empty slots.

---

## 3. Sparse Arrays (holes inside array)

* Arrays can have "holes" where indexes are missing.

```js
let arr = [];
arr[3] = "hello";
console.log(arr);       // [ <3 empty items>, 'hello' ]
console.log(arr.length); // 4
```

👉 Length counts the **highest index + 1**, even if in between elements are missing.

---

## 4. Arrays are Objects

```js
console.log(typeof []);         // "object"
console.log(Array.isArray([])); // true ✅ (use this to check array)
```

---

## 5. Memory (Visual)

Think of an array as a **special object** where:

* Keys are numeric (0, 1, 2, …)
* Values are stored as properties.
* `length` is automatically updated.

Example:

```js
let colors = ["red", "green", "blue"];
```

Internally like:

```
{
  0: "red",
  1: "green",
  2: "blue",
  length: 3
}
```

---

# ✅ Quick Summary

* Use **array literals** `[]` (recommended).
* `new Array(n)` creates an empty array with `n` slots.
* Arrays can hold **any type** and even be **sparse**.
* Always check with `Array.isArray()`.

# 📌 Arrays in JavaScript — Accessing & Modifying

## 1. Accessing Elements

* Use **bracket notation** with an index.
* Index starts at **0**.

```js
let fruits = ["apple", "banana", "cherry"];

console.log(fruits[0]); // "apple"
console.log(fruits[2]); // "cherry"
console.log(fruits[3]); // undefined (out of range)
```

---

## 2. Using `.at()` (ES2022+)

* `.at(index)` works like `[]`, but supports **negative indices**.
* Very useful for the last element.

```js
let colors = ["red", "green", "blue"];

console.log(colors.at(0));   // "red"
console.log(colors.at(-1));  // "blue" ✅ last element
console.log(colors.at(-2));  // "green"
```

---

## 3. Updating Elements

* Arrays are **mutable** → you can change elements by index.

```js
let nums = [10, 20, 30];
nums[1] = 99;
console.log(nums); // [10, 99, 30]
```

---

## 4. Adding New Elements

* If you assign a value to an index greater than current length, it creates a **sparse array**.

```js
let arr = [1, 2];
arr[5] = 100;
console.log(arr);       // [1, 2, <3 empty items>, 100]
console.log(arr.length); // 6
```

---

## 5. Deleting Elements

* `delete arr[index]` removes the value but leaves a **hole**.

```js
let fruits = ["apple", "banana", "cherry"];
delete fruits[1];

console.log(fruits);       // ["apple", empty, "cherry"]
console.log(fruits.length); // 3
```

👉 Better to use `splice()` (we’ll cover later) to remove elements without leaving holes.

---

## 6. Checking Existence

* You can check if an index exists using `in`.

```js
let arr = [1, 2, 3];
console.log(1 in arr); // true (index 1 exists)
console.log(5 in arr); // false
```

---

# ✅ Quick Summary

* Access with `[]` or `.at()`.
* `.at(-1)` → last element (new and neat).
* Assigning beyond length → creates sparse arrays.
* `delete` leaves holes → avoid unless intentional.

# 📌 Arrays in JavaScript — Properties & Basics

## 1. The `.length` Property

* `.length` gives you the **highest index + 1**.
* It updates automatically when you add/remove elements.

```js
let arr = ["a", "b", "c"];
console.log(arr.length); // 3

arr.push("d");
console.log(arr.length); // 4

arr[10] = "z";
console.log(arr.length); // 11 (even though only 5 values exist)
```

⚠️ **Length counts sparse holes too**.

---

## 2. Manually Changing `.length`

* You can **truncate** or **expand** arrays by setting `.length`.

```js
let nums = [1, 2, 3, 4, 5];
nums.length = 3;
console.log(nums); // [1, 2, 3]  (truncated)

nums.length = 6;
console.log(nums); // [1, 2, 3, <3 empty items>]
```

---

## 3. Type of Arrays

* Arrays are actually **Objects**.
* But you shouldn’t check with `typeof` → it returns `"object"`.

```js
let arr = [1, 2, 3];
console.log(typeof arr);         // "object" ❌
console.log(Array.isArray(arr)); // true ✅
```

---

## 4. `instanceof` Check

Another way to check if it’s an array:

```js
console.log(arr instanceof Array); // true
```

---

## 5. Empty Arrays vs Holes

* An empty array: `[]`
* Sparse array with holes:

```js
let arr1 = [];
let arr2 = [ , , , ]; // 3 holes

console.log(arr1.length); // 0
console.log(arr2.length); // 3
```

⚠️ Holes are not `undefined` values — they’re literally **missing elements**.

---

# ✅ Quick Summary

* `.length` auto-updates but counts holes.
* Setting `.length` manually can truncate or expand arrays.
* Use `Array.isArray()` to check arrays.
* Empty arrays ≠ Sparse arrays (holes).

---

Awesome 🚀 Now let’s dig into **Step 4: Mutating Array Methods**.
These methods **change (mutate) the original array**.

---

# 📌 Mutating Array Methods in JavaScript

## 1. `push()` → Add to End

```js
let arr = [1, 2];
arr.push(3);
console.log(arr); // [1, 2, 3]
```

---

## 2. `pop()` → Remove from End

```js
let arr = [1, 2, 3];
arr.pop(); 
console.log(arr); // [1, 2]
```

---

## 3. `unshift()` → Add to Start

```js
let arr = [2, 3];
arr.unshift(1);
console.log(arr); // [1, 2, 3]
```

---

## 4. `shift()` → Remove from Start

```js
let arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

---

## 5. `splice()` → Insert, Remove, Replace

Super powerful method.

**(a) Remove items**

```js
let arr = ["a", "b", "c", "d"];
arr.splice(1, 2); // remove 2 elements from index 1
console.log(arr); // ["a", "d"]
```

**(b) Insert items**

```js
let arr = ["a", "d"];
arr.splice(1, 0, "b", "c"); // from index 1, remove 0, insert "b","c"
console.log(arr); // ["a", "b", "c", "d"]
```

**(c) Replace items**

```js
let arr = ["a", "b", "c"];
arr.splice(1, 1, "x"); // replace 1 element at index 1 with "x"
console.log(arr); // ["a", "x", "c"]
```

---

## 6. `sort()` → Sort Array (⚠️ string-based by default)

```js
let arr = [10, 5, 2];
arr.sort();
console.log(arr); // [10, 2, 5] (string sort!)
```

👉 Use a compare function for numbers:

```js
arr.sort((a, b) => a - b); 
console.log(arr); // [2, 5, 10]
```

---

## 7. `reverse()` → Reverse Order

```js
let arr = [1, 2, 3];
arr.reverse();
console.log(arr); // [3, 2, 1]
```

---

# ✅ Quick Summary

* `push` / `pop` → work at the **end**.
* `shift` / `unshift` → work at the **start** (slower than push/pop).
* `splice` → swiss army knife (insert, remove, replace).
* `sort` → beware, sorts as **strings by default**.
* `reverse` → reverses in-place.

---
**Step 5: Non-Mutating Array Methods**.
These methods **do NOT change the original array**, they return a **new one** or just give results.

---

# 📌 Non-Mutating Array Methods in JavaScript

---

## 1. `slice()` → Copy part of an array

```js
let arr = ["a", "b", "c", "d"];
let newArr = arr.slice(1, 3); // from index 1 to before 3
console.log(newArr); // ["b", "c"]
console.log(arr);    // ["a", "b", "c", "d"] (unchanged)
```

👉 Great for shallow copying.

---

## 2. `concat()` → Merge arrays

```js
let arr1 = [1, 2];
let arr2 = [3, 4];
let arr3 = arr1.concat(arr2);
console.log(arr3); // [1, 2, 3, 4]
```

---

## 3. `map()` → Transform each element

```js
let nums = [1, 2, 3];
let doubled = nums.map(n => n * 2);
console.log(doubled); // [2, 4, 6]
console.log(nums);    // [1, 2, 3]
```

---

## 4. `filter()` → Keep only matching elements

```js
let nums = [1, 2, 3, 4, 5];
let evens = nums.filter(n => n % 2 === 0);
console.log(evens); // [2, 4]
```

---

## 5. `reduce()` → Accumulate into one value

```js
let nums = [1, 2, 3, 4];
let sum = nums.reduce((acc, n) => acc + n, 0);
console.log(sum); // 10
```

👉 Can also build objects, arrays, etc.

---

## 6. `find()` → First element that matches

```js
let nums = [5, 10, 15];
let found = nums.find(n => n > 8);
console.log(found); // 10
```

---

## 7. `findIndex()` → Index of first match

```js
let nums = [5, 10, 15];
let idx = nums.findIndex(n => n > 8);
console.log(idx); // 1
```

---

## 8. `every()` → All elements match?

```js
let nums = [2, 4, 6];
console.log(nums.every(n => n % 2 === 0)); // true
```

---

## 9. `some()` → At least one matches?

```js
let nums = [1, 3, 5, 6];
console.log(nums.some(n => n % 2 === 0)); // true
```

---

## 10. `includes()` → Value exists?

```js
let fruits = ["apple", "banana"];
console.log(fruits.includes("banana")); // true
console.log(fruits.includes("cherry")); // false
```

---

## 11. `indexOf()` → First index of value

```js
let fruits = ["apple", "banana", "apple"];
console.log(fruits.indexOf("apple"));  // 0
console.log(fruits.indexOf("mango"));  // -1
```

---

## 12. `lastIndexOf()` → Last index of value

```js
let fruits = ["apple", "banana", "apple"];
console.log(fruits.lastIndexOf("apple")); // 2
```

---

# ✅ Quick Summary

* `slice`, `concat` → copy/merge arrays.
* `map`, `filter`, `reduce` → transform, select, accumulate.
* `find`, `findIndex` → locate elements.
* `every`, `some` → boolean checks.
* `includes`, `indexOf`, `lastIndexOf` → membership + positions.

---

**Step 6: Array Iteration Methods**.
These are ways to **loop through arrays** and process items.

---

# 📌 Iterating Over Arrays in JavaScript

---

## 1. Classic `for` Loop

* The most flexible.
* You control index and step size.

```js
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i++) {
  console.log(i, arr[i]);
}
// 0 "a"
// 1 "b"
// 2 "c"
```

---

## 2. `for...of` → Direct values

* Cleaner syntax.
* Iterates over **values**, not keys.

```js
let arr = ["a", "b", "c"];
for (let value of arr) {
  console.log(value);
}
// "a" "b" "c"
```

---

## 3. `forEach()` → Array method

* Runs a function for each element.
* You get `(value, index, array)`.
* Can’t `break` or `return` early (⚠️).

```js
let arr = ["a", "b", "c"];
arr.forEach((value, index) => {
  console.log(index, value);
});
// 0 "a"
// 1 "b"
// 2 "c"
```

---

## 4. ❌ `for...in` → Not for arrays

* Iterates over **keys (property names)**.
* Good for objects, but not recommended for arrays (includes custom properties).

```js
let arr = ["a", "b", "c"];
for (let key in arr) {
  console.log(key, arr[key]);
}
// 0 "a"
// 1 "b"
// 2 "c"
```

⚠️ Problem: If you extend `Array.prototype`, it shows up here.

---

## 5. `map()` vs `forEach()`

* Both iterate over the array.
* `map()` returns a **new array**.
* `forEach()` just runs a function (returns `undefined`).

```js
let nums = [1, 2, 3];

// with map
let doubled = nums.map(n => n * 2);
console.log(doubled); // [2, 4, 6]

// with forEach
let doubled2 = [];
nums.forEach(n => doubled2.push(n * 2));
console.log(doubled2); // [2, 4, 6]
```

---

## 6. Iterating Sparse Arrays

* Holes are skipped by `forEach`, `map`, `for...of`.
* But `for` and `for...in` **see them differently**.

```js
let arr = [1, , 3];

// for loop
for (let i = 0; i < arr.length; i++) {
  console.log(i, arr[i]);
}
// 0 1
// 1 undefined
// 2 3

// forEach
arr.forEach(v => console.log(v));
// 1
// 3 (skips hole)
```

---

# ✅ Quick Summary

* `for` → most control (can break, skip, step).
* `for...of` → clean values loop.
* `forEach` → callback style, no break.
* `for...in` → not for arrays (iterates keys, can be misleading).
* Sparse arrays behave differently across methods.

---
**Step 7: ES6+ Array Features**.
These are modern additions that make arrays much more powerful.

---

# 📌 Arrays in JavaScript — ES6+ Features

---

## 1. **Array Destructuring**

* Extract values into variables easily.

```js
let arr = ["apple", "banana", "cherry"];

// basic
let [a, b] = arr;
console.log(a, b); // "apple" "banana"

// skip values
let [, , c] = arr;
console.log(c); // "cherry"

// with rest
let [first, ...rest] = arr;
console.log(first); // "apple"
console.log(rest);  // ["banana", "cherry"]
```

---

## 2. **Spread Operator (`...`)**

* Expands arrays into elements.

```js
let arr1 = [1, 2];
let arr2 = [3, 4];

let merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4]
```

* Copying arrays:

```js
let copy = [...arr1];
console.log(copy); // [1, 2]
```

---

## 3. **Rest Parameters**

* Collects function arguments into an array.

```js
function sum(...nums) {
  return nums.reduce((a, b) => a + b, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

---

## 4. **Array.from()**

* Converts array-like or iterable to real array.

```js
let str = "hello";
let arr = Array.from(str);
console.log(arr); // ["h", "e", "l", "l", "o"]
```

👉 Can also take a mapping function:

```js
let doubled = Array.from([1, 2, 3], x => x * 2);
console.log(doubled); // [2, 4, 6]
```

---

## 5. **Array.of()**

* Creates array from arguments.

```js
let arr = Array.of(3, 5, 7);
console.log(arr); // [3, 5, 7]
```

👉 Different from `new Array(3)` which creates empty slots.

```js
console.log(new Array(3));   // [empty × 3]
console.log(Array.of(3));    // [3]
```

---

## 6. **Array.fill()**

* Fills array with a static value.

```js
let arr = new Array(5).fill(0);
console.log(arr); // [0, 0, 0, 0, 0]

arr.fill(9, 1, 3);
console.log(arr); // [0, 9, 9, 0, 0]
```

---

## 7. **Array.flat()**

* Flattens nested arrays.

```js
let arr = [1, [2, [3, 4]]];
console.log(arr.flat());     // [1, 2, [3, 4]]
console.log(arr.flat(2));    // [1, 2, 3, 4]
```

---

## 8. **Array.flatMap()**

* Combines `map()` + `flat(1)`.

```js
let arr = ["hi", "bye"];
let result = arr.flatMap(word => word.split(""));
console.log(result); // ["h", "i", "b", "y", "e"]
```

---

# ✅ Quick Summary

* **Destructuring** → extract elements.
* **Spread** → expand/copy arrays.
* **Rest** → gather arguments into array.
* **from / of** → make arrays from iterables or values.
* **fill** → fill array with values.
* **flat / flatMap** → flatten nested arrays.

---
 **Step 8: Tricky Cases & Gotchas**.
These are places where JavaScript arrays surprise even experienced devs.

---

# 📌 Arrays in JavaScript — Tricky Cases & Gotchas

---

## 1. Copying Arrays (Shallow vs Deep)

```js
let arr = [1, 2, 3];

// shallow copy ✅
let copy1 = arr.slice();
let copy2 = [...arr];
let copy3 = Array.from(arr);

copy1[0] = 99;
console.log(arr);   // [1, 2, 3] (original safe)
console.log(copy1); // [99, 2, 3]
```

⚠️ But nested objects/arrays are still **shared** (shallow copy).

```js
let arr = [[1], [2]];
let copy = [...arr];
copy[0][0] = 99;

console.log(arr);  // [[99], [2]] ❌ (original changed)
```

👉 For deep copy, use `structuredClone()` (modern browsers) or JSON tricks:

```js
let deep = structuredClone(arr);
```

---

## 2. Reference vs Value

```js
let a = [1, 2];
let b = a;

b.push(3);
console.log(a); // [1, 2, 3] ❌ (same reference)
```

👉 Arrays are **objects**, so they copy by **reference**, not by value.

---

## 3. Sorting Pitfalls

```js
let nums = [1, 2, 15];
nums.sort();
console.log(nums); // [1, 15, 2] ❌ (string sort)
```

👉 Always pass a comparator for numbers:

```js
nums.sort((a, b) => a - b);
console.log(nums); // [1, 2, 15]
```

---

## 4. Holes in Arrays

```js
let arr = [1, , 3];
console.log(arr.length); // 3
console.log(arr[1]);     // undefined
```

Iteration differences:

```js
// skips hole
arr.forEach(v => console.log(v));
// 1
// 3

// includes hole
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// 1
// undefined
// 3
```

---

## 5. `==` vs `===` with Arrays

```js
console.log([1,2] == [1,2]);   // false
console.log([1,2] === [1,2]);  // false
```

👉 Because they’re **different references**.
But if same reference:

```js
let x = [1,2];
let y = x;
console.log(x === y); // true ✅
```

---

# ✅ Quick Summary

* Copying arrays → shallow by default, use `structuredClone` for deep.
* Arrays are reference types (assignment copies reference).
* Sorting is string-based unless comparator is provided.
* Holes behave differently across iteration methods.
* Arrays compared by reference, not value.


# 📌 Arrays in JavaScript — Summary

## ✅ Mutating vs Non-Mutating Methods

| **Category**        | **Method**                   | **Mutates Original?** | **Returns**                      |
| ------------------- | ---------------------------- | --------------------- | -------------------------------- |
| **Adding/Removing** | `push()`, `pop()`            | ✅ Yes                 | Modified array / element removed |
|                     | `shift()`, `unshift()`       | ✅ Yes                 | Modified array / element removed |
|                     | `splice()`                   | ✅ Yes                 | Removed elements (array)         |
| **Reordering**      | `sort()`, `reverse()`        | ✅ Yes                 | Sorted/reversed array            |
| **Copying/Merging** | `slice()`                    | ❌ No                  | New array                        |
|                     | `concat()`                   | ❌ No                  | New merged array                 |
| **Transforming**    | `map()`                      | ❌ No                  | New transformed array            |
|                     | `filter()`                   | ❌ No                  | New filtered array               |
|                     | `reduce()`, `reduceRight()`  | ❌ No                  | Single accumulated value         |
| **Searching**       | `find()`, `findIndex()`      | ❌ No                  | Element / index / undefined      |
|                     | `includes()`                 | ❌ No                  | Boolean                          |
|                     | `indexOf()`, `lastIndexOf()` | ❌ No                  | Index / -1                       |
| **Checks**          | `every()`, `some()`          | ❌ No                  | Boolean                          |
| **ES6+**            | `flat()`, `flatMap()`        | ❌ No                  | New array                        |
|                     | `from()`, `of()`, `fill()`   | ❌ No (except `fill`)  | New array / filled array         |

---

# ✅ Big Takeaways

* Mutating methods **change** the original array.
* Non-mutating methods **return new arrays** or values.
* Always use non-mutating methods in functional programming style.
* Be careful with `sort()` (default is string comparison).
* For **deep copies**, use `structuredClone()` or libraries.

---
